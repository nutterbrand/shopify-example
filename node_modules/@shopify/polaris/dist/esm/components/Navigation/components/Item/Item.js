import { Key } from '../../../../types.js';
import { objectWithoutProperties as _objectWithoutProperties } from '../../../../_virtual/_rollupPluginBabelHelpers.js';
import React$1, { useContext, useState, useEffect, useCallback } from 'react';
import { useMediaQuery } from '../../../../utilities/media-query/hooks.js';
import { useI18n } from '../../../../utilities/i18n/hooks.js';
import { classNames } from '../../../../utilities/css.js';
import { Icon as Icon$1 } from '../../../Icon/Icon.js';
import { UnstyledLink as UnstyledLink$1 } from '../../../UnstyledLink/UnstyledLink.js';
import { Badge as Badge$1 } from '../../../Badge/Badge.js';
import { Indicator as Indicator$1 } from '../../../Indicator/Indicator.js';
import { NavigationContext } from '../../context.js';
import styles from '../../Navigation.scss.js';
import { Secondary as Secondary$1 } from './components/Secondary/Secondary.js';

var MatchState;

(function (MatchState) {
  MatchState[MatchState["MatchForced"] = 0] = "MatchForced";
  MatchState[MatchState["MatchUrl"] = 1] = "MatchUrl";
  MatchState[MatchState["MatchPaths"] = 2] = "MatchPaths";
  MatchState[MatchState["Excluded"] = 3] = "Excluded";
  MatchState[MatchState["NoMatch"] = 4] = "NoMatch";
})(MatchState || (MatchState = {}));

var _ref = /*#__PURE__*/React$1.createElement(Indicator$1, {
  pulse: true
});

function Item({
  url,
  icon,
  label,
  subNavigationItems = [],
  secondaryAction,
  disabled,
  onClick,
  accessibilityLabel,
  selected: selectedOverride,
  badge,
  new: isNew,
  matches,
  exactMatch,
  matchPaths,
  excludePaths
}) {
  const i18n = useI18n();
  const {
    isNavigationCollapsed
  } = useMediaQuery();
  const {
    location,
    onNavigationDismiss
  } = useContext(NavigationContext);
  const [expanded, setExpanded] = useState(false);
  const [keyFocused, setKeyFocused] = useState(false);
  useEffect(() => {
    if (!isNavigationCollapsed && expanded) {
      setExpanded(false);
    }
  }, [expanded, isNavigationCollapsed]);
  const handleKeyUp = useCallback(event => {
    if (event.keyCode === Key.Tab) {
      !keyFocused && setKeyFocused(true);
    }
  }, [keyFocused]);
  const handleBlur = useCallback(() => {
    keyFocused && setKeyFocused(false);
  }, [keyFocused]);
  const tabIndex = disabled ? -1 : 0;
  const hasNewChild = subNavigationItems.filter(subNavigationItem => subNavigationItem.new).length > 0;
  const indicatorMarkup = hasNewChild ? /*#__PURE__*/React$1.createElement("span", {
    className: styles.Indicator
  }, _ref) : null;
  const iconMarkup = icon ? /*#__PURE__*/React$1.createElement("div", {
    className: styles.Icon
  }, /*#__PURE__*/React$1.createElement(Icon$1, {
    source: icon
  })) : null;
  let badgeMarkup = null;

  if (isNew) {
    badgeMarkup = /*#__PURE__*/React$1.createElement(Badge$1, {
      status: "new",
      size: "small"
    }, i18n.translate('Polaris.Badge.STATUS_LABELS.new'));
  } else if (typeof badge === 'string') {
    badgeMarkup = /*#__PURE__*/React$1.createElement(Badge$1, {
      status: "new",
      size: "small"
    }, badge);
  } else {
    badgeMarkup = badge;
  }

  const wrappedBadgeMarkup = badgeMarkup == null ? null : /*#__PURE__*/React$1.createElement("div", {
    className: styles.Badge
  }, badgeMarkup);
  const itemContentMarkup = /*#__PURE__*/React$1.createElement(React$1.Fragment, null, iconMarkup, /*#__PURE__*/React$1.createElement("span", {
    className: styles.Text
  }, label, indicatorMarkup), wrappedBadgeMarkup);

  if (url == null) {
    const _className = classNames(styles.Item, disabled && styles['Item-disabled'], keyFocused && styles.keyFocused);

    return /*#__PURE__*/React$1.createElement("li", {
      className: styles.ListItem
    }, /*#__PURE__*/React$1.createElement("button", {
      type: "button",
      className: _className,
      disabled: disabled,
      "aria-disabled": disabled,
      "aria-label": accessibilityLabel,
      onClick: getClickHandler(onClick),
      onKeyUp: handleKeyUp,
      onBlur: handleBlur
    }, itemContentMarkup));
  }

  const secondaryActionMarkup = secondaryAction && /*#__PURE__*/React$1.createElement(UnstyledLink$1, {
    external: true,
    url: secondaryAction.url,
    className: styles.SecondaryAction,
    tabIndex: tabIndex,
    "aria-disabled": disabled,
    "aria-label": secondaryAction.accessibilityLabel
  }, /*#__PURE__*/React$1.createElement(Icon$1, {
    source: secondaryAction.icon
  }));
  const matchState = matchStateForItem({
    url,
    matches,
    exactMatch,
    matchPaths,
    excludePaths
  }, location);
  const matchingSubNavigationItems = subNavigationItems.filter(item => {
    const subMatchState = matchStateForItem(item, location);
    return subMatchState === MatchState.MatchForced || subMatchState === MatchState.MatchUrl || subMatchState === MatchState.MatchPaths;
  });
  const childIsActive = matchingSubNavigationItems.length > 0;
  const selected = selectedOverride == null ? matchState === MatchState.MatchForced || matchState === MatchState.MatchUrl || matchState === MatchState.MatchPaths : selectedOverride;
  const showExpanded = selected || expanded || childIsActive;
  const itemClassName = classNames(styles.Item, disabled && styles['Item-disabled'], selected && subNavigationItems.length === 0 && styles['Item-selected'], showExpanded && styles.subNavigationActive, keyFocused && styles.keyFocused);
  let secondaryNavigationMarkup = null;

  if (subNavigationItems.length > 0 && showExpanded) {
    const longestMatch = matchingSubNavigationItems.sort(({
      url: firstUrl
    }, {
      url: secondUrl
    }) => secondUrl.length - firstUrl.length)[0];
    const SecondaryNavigationClassName = classNames(styles.SecondaryNavigation, !icon && styles['SecondaryNavigation-noIcon']);
    secondaryNavigationMarkup = /*#__PURE__*/React$1.createElement("div", {
      className: SecondaryNavigationClassName
    }, /*#__PURE__*/React$1.createElement(Secondary$1, {
      expanded: showExpanded
    }, subNavigationItems.map(item => {
      const {
        label
      } = item,
            rest = _objectWithoutProperties(item, ["label"]);

      return /*#__PURE__*/React$1.createElement(Item, Object.assign({}, rest, {
        key: label,
        label: label,
        matches: item === longestMatch,
        onClick: onNavigationDismiss
      }));
    })));
  }

  const className = classNames(styles.ListItem, secondaryAction && styles['ListItem-hasAction']);
  return /*#__PURE__*/React$1.createElement("li", {
    className: className
  }, /*#__PURE__*/React$1.createElement("div", {
    className: styles.ItemWrapper
  }, /*#__PURE__*/React$1.createElement(UnstyledLink$1, {
    url: url,
    className: itemClassName,
    tabIndex: tabIndex,
    "aria-disabled": disabled,
    "aria-label": accessibilityLabel,
    onClick: getClickHandler(onClick),
    onKeyUp: handleKeyUp,
    onBlur: handleBlur
  }, itemContentMarkup), secondaryActionMarkup), secondaryNavigationMarkup);

  function getClickHandler(onClick) {
    return event => {
      const {
        currentTarget
      } = event;

      if (currentTarget.getAttribute('href') === location) {
        event.preventDefault();
      }

      if (subNavigationItems && subNavigationItems.length > 0 && isNavigationCollapsed) {
        event.preventDefault();
        setExpanded(!expanded);
      } else if (onNavigationDismiss) {
        onNavigationDismiss();

        if (onClick && onClick !== onNavigationDismiss) {
          onClick();
        }

        return;
      }

      if (onClick) {
        onClick();
      }
    };
  }
}
function isNavigationItemActive(navigationItem, currentPath) {
  const matchState = matchStateForItem(navigationItem, currentPath);
  const matchingSubNavigationItems = navigationItem.subNavigationItems && navigationItem.subNavigationItems.filter(item => {
    const subMatchState = matchStateForItem(item, currentPath);
    return subMatchState === MatchState.MatchForced || subMatchState === MatchState.MatchUrl || subMatchState === MatchState.MatchPaths;
  });
  const childIsActive = matchingSubNavigationItems && matchingSubNavigationItems.length > 0;
  const selected = matchState === MatchState.MatchForced || matchState === MatchState.MatchUrl || matchState === MatchState.MatchPaths;
  return selected || childIsActive;
}

function normalizePathname(pathname) {
  const barePathname = pathname.split('?')[0].split('#')[0];
  return barePathname.endsWith('/') ? barePathname : `${barePathname}/`;
}

function safeEqual(location, path) {
  return normalizePathname(location) === normalizePathname(path);
}

function safeStartsWith(location, path) {
  return normalizePathname(location).startsWith(normalizePathname(path));
}

function matchStateForItem({
  url,
  matches,
  exactMatch,
  matchPaths,
  excludePaths
}, location) {
  if (url == null) {
    return MatchState.NoMatch;
  }

  if (matches) {
    return MatchState.MatchForced;
  }

  if (matches === false || excludePaths && excludePaths.some(path => safeStartsWith(location, path))) {
    return MatchState.Excluded;
  }

  if (matchPaths && matchPaths.some(path => safeStartsWith(location, path))) {
    return MatchState.MatchPaths;
  }

  const matchesUrl = exactMatch ? safeEqual(location, url) : safeStartsWith(location, url);
  return matchesUrl ? MatchState.MatchUrl : MatchState.NoMatch;
}

export { Item, isNavigationItemActive };
