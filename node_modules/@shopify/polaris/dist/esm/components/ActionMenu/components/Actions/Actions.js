import { objectWithoutProperties as _objectWithoutProperties } from '../../../../_virtual/_rollupPluginBabelHelpers.js';
import React$1, { useRef, useState, useCallback, useMemo, useEffect } from 'react';
import { useFeatures } from '../../../../utilities/features/hooks.js';
import debounce$1 from 'lodash/debounce';
import { EventListener as EventListener$1 } from '../../../EventListener/EventListener.js';
import { useI18n } from '../../../../utilities/i18n/hooks.js';
import { classNames } from '../../../../utilities/css.js';
import { ButtonGroup as ButtonGroup$1 } from '../../../ButtonGroup/ButtonGroup.js';
import { MenuAction as MenuAction$1 } from '../MenuAction/MenuAction.js';
import { SecondaryAction as SecondaryAction$1 } from '../SecondaryAction/SecondaryAction.js';
import { MenuGroup as MenuGroup$1 } from '../MenuGroup/MenuGroup.js';
import styles from './Actions.scss.js';

const ACTION_SPACING = 8;
function Actions({
  actions = [],
  groups = []
}) {
  const i18n = useI18n();
  const {
    newDesignLanguage
  } = useFeatures();
  const actionsLayoutRef = useRef(null);
  const menuGroupWidthRef = useRef(0);
  const actionWidthsRef = useRef([]);
  const availableWidthRef = useRef(0);
  const [activeMenuGroup, setActiveMenuGroup] = useState(undefined);
  const [showableActions, setShowableActions] = useState([]);
  const [rolledUpActions, setRolledUpActions] = useState([]);
  const defaultRollupGroup = {
    title: i18n.translate('Polaris.Actions.moreActions'),
    actions: []
  };
  const lastMenuGroup = [...groups].pop();
  const lastMenuGroupWidth = [...actionWidthsRef.current].pop() || 0;
  const handleActionsOffsetWidth = useCallback(width => {
    actionWidthsRef.current = [...actionWidthsRef.current, width];
  }, []);
  const handleMenuGroupToggle = useCallback(group => setActiveMenuGroup(activeMenuGroup ? undefined : group), [activeMenuGroup]);
  const handleMenuGroupClose = useCallback(() => setActiveMenuGroup(undefined), []);
  const measureActions = useCallback(() => {
    if (!newDesignLanguage || actionWidthsRef.current.length === 0 || availableWidthRef.current === 0) {
      return;
    }

    const actionsAndGroups = [...actions, ...groups];

    if (actionsAndGroups.length === 1) {
      setShowableActions(actionsAndGroups);
      return;
    }

    let currentAvailableWidth = availableWidthRef.current;
    let newShowableActions = [];
    let newRolledUpActions = [];
    actionsAndGroups.forEach((action, index) => {
      const canFitAction = actionWidthsRef.current[index] + menuGroupWidthRef.current + ACTION_SPACING + lastMenuGroupWidth <= currentAvailableWidth;

      if (canFitAction) {
        currentAvailableWidth -= actionWidthsRef.current[index];
        newShowableActions = [...newShowableActions, action];
      } else {
        // Find last group if it exists and always render it as a rolled up action below
        if (action === lastMenuGroup) return;
        currentAvailableWidth = 0;
        newRolledUpActions = [...newRolledUpActions, action];
      }
    });
    setShowableActions(newShowableActions);
    setRolledUpActions(newRolledUpActions);
  }, [actions, groups, lastMenuGroup, lastMenuGroupWidth, newDesignLanguage]);
  const handleResize = useMemo(() => debounce$1(() => {
    if (!newDesignLanguage || !actionsLayoutRef.current) return;
    availableWidthRef.current = actionsLayoutRef.current.offsetWidth;
    measureActions();
  }, 20, {
    leading: false,
    trailing: true,
    maxWait: 40
  }), [newDesignLanguage, measureActions]);
  useEffect(() => {
    if (!actionsLayoutRef.current) {
      return;
    }

    availableWidthRef.current = actionsLayoutRef.current.offsetWidth;
    measureActions();
  }, [measureActions]);
  const className = classNames(styles.ActionsLayout, newDesignLanguage && styles.newDesignLanguage);
  const actionsMarkup = actions.map(action => {
    if (newDesignLanguage && showableActions.length > 0 || rolledUpActions.includes(action)) return null;

    const {
      content,
      onAction
    } = action,
          rest = _objectWithoutProperties(action, ["content", "onAction"]);

    return newDesignLanguage ? /*#__PURE__*/React$1.createElement(SecondaryAction$1, Object.assign({
      key: content,
      onClick: onAction
    }, rest, {
      getOffsetWidth: handleActionsOffsetWidth
    }), content) : /*#__PURE__*/React$1.createElement(MenuAction$1, Object.assign({
      key: content,
      content: content,
      onAction: onAction
    }, rest));
  });
  const rollUppableActionsMarkup = showableActions.length > 0 ? showableActions.map(action => action.content && /*#__PURE__*/React$1.createElement(SecondaryAction$1, Object.assign({
    key: action.content
  }, action, {
    getOffsetWidth: handleActionsOffsetWidth
  }), action.content)) : null;
  const groupsMarkup = [...groups, defaultRollupGroup].filter(group => {
    return groups.length === 0 && group === defaultRollupGroup ? group : group === lastMenuGroup || group !== defaultRollupGroup && !rolledUpActions.includes(group);
  }).map(group => {
    const {
      title,
      actions: groupActions
    } = group,
          rest = _objectWithoutProperties(group, ["title", "actions"]);

    const finalRolledUpActions = rolledUpActions.reduce((memo, action) => {
      memo.push(...(isMenuGroup(action) ? action.actions : [action]));
      return memo;
    }, []);
    const isDefaultGroup = group === defaultRollupGroup;

    if (isDefaultGroup && groups.length === 0 && finalRolledUpActions.length > 0) {
      return /*#__PURE__*/React$1.createElement(MenuGroup$1, Object.assign({
        key: title,
        title: title,
        active: title === activeMenuGroup,
        actions: [...(finalRolledUpActions || actions), ...(!isDefaultGroup ? groupActions : [])]
      }, rest, {
        onOpen: handleMenuGroupToggle,
        onClose: handleMenuGroupClose,
        getOffsetWidth: handleActionsOffsetWidth
      }));
    } else if (!isDefaultGroup && (groups.length > 0 || groupActions.length || actions.length)) {
      return /*#__PURE__*/React$1.createElement(MenuGroup$1, Object.assign({
        key: title,
        title: title,
        active: title === activeMenuGroup,
        actions: [...(finalRolledUpActions || actions), ...(!isDefaultGroup ? groupActions : [])]
      }, rest, {
        onOpen: handleMenuGroupToggle,
        onClose: handleMenuGroupClose,
        getOffsetWidth: handleActionsOffsetWidth
      }));
    }
  });
  const groupedActionsMarkup = newDesignLanguage ? /*#__PURE__*/React$1.createElement(ButtonGroup$1, {
    spacing: "extraTight"
  }, rollUppableActionsMarkup, actionsMarkup, groupsMarkup) : /*#__PURE__*/React$1.createElement(React$1.Fragment, null, actionsMarkup, groupsMarkup);
  return /*#__PURE__*/React$1.createElement("div", {
    className: className,
    ref: actionsLayoutRef
  }, groupedActionsMarkup, /*#__PURE__*/React$1.createElement(EventListener$1, {
    event: "resize",
    handler: handleResize
  }));
}

function isMenuGroup(actionOrMenuGroup) {
  return 'title' in actionOrMenuGroup;
}

export { Actions };
