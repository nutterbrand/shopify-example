import tokens$1 from '@shopify/polaris-tokens';
import { colorFactory } from '@shopify/polaris-tokens/dist-modern';
import { mergeConfigs } from '@shopify/polaris-tokens/dist-modern/utils';
import { config as config$1 } from '@shopify/polaris-tokens/dist-modern/configs/base';
import { colorToHsla, hslToRgb, hslToString } from '../color-transformers.ts.esnext';
import { isLight } from '../color-validation.ts.esnext';
import { constructColorName } from '../color-names.ts.esnext';
import { createLightColor } from '../color-manipulation.ts.esnext';
import { needsVariantList } from './config.ts.esnext';

function buildCustomPropertiesNoMemo(themeConfig, newDesignLanguage, tokens) {
  const {
    colors = {},
    colorScheme,
    config,
    frameOffset = 0
  } = themeConfig;
  const mergedConfig = mergeConfigs(config$1, config || {});
  return newDesignLanguage ? customPropertyTransformer({ ...colorFactory(colors, colorScheme, mergedConfig),
    ...tokens,
    frameOffset: `${frameOffset}px`
  }) : { ...buildLegacyColors(themeConfig),
    ...customPropertyTransformer({
      frameOffset: `${frameOffset}px`
    })
  };
}
function buildThemeContext(themeConfig, cssCustomProperties) {
  const {
    logo,
    colors = {},
    colorScheme
  } = themeConfig;
  const {
    topBar,
    ...newDesignLanguageColors
  } = colors;
  return {
    logo,
    cssCustomProperties: toString(cssCustomProperties),
    colors: newDesignLanguageColors,
    colorScheme
  };
}
function toString(obj) {
  if (obj) {
    return Object.entries(obj).map(pair => pair.join(':')).join(';');
  } else {
    return undefined;
  }
}

function customPropertyTransformer(properties) {
  return Object.entries(properties).reduce((transformed, [key, value]) => ({ ...transformed,
    [toCssCustomPropertySyntax(key)]: value
  }), {});
}

function toCssCustomPropertySyntax(camelCase) {
  return `--p-${camelCase.replace(/([A-Z0-9])/g, '-$1').toLowerCase()}`;
}

function buildLegacyColors(theme) {
  let colorPairs;
  const colors = theme && theme.colors && theme.colors.topBar ? theme.colors.topBar : {
    background: '#00848e',
    backgroundLighter: '#1d9ba4',
    color: '#f9fafb'
  };
  const colorKey = 'topBar';
  const colorKeys = Object.keys(colors);

  if (colorKeys.length > 1) {
    colorPairs = colorKeys.map(key => {
      return [constructColorName(colorKey, key), colors[key]];
    });
  } else {
    colorPairs = parseColors([colorKey, colors]);
  }

  return colorPairs.reduce((state, [key, value]) => ({ ...state,
    [key]: value
  }), {});
}

function needsVariant(name) {
  return needsVariantList.includes(name);
}

function lightenToString(color, lightness, saturation) {
  return hslToString(createLightColor(color, lightness, saturation));
}

function setTextColor(name, variant = 'dark') {
  if (variant === 'light') {
    return [name, tokens$1.colorInk];
  }

  return [name, tokens$1.colorWhite];
}
function setBorderColor(name, variant = 'dark') {
  if (variant === 'light') {
    return [name, tokens$1.colorInkLighter];
  }

  return [name, tokens$1.colorSkyDark];
}
function setTheme(color, baseName, key, variant) {
  const colorPairs = [];

  switch (variant) {
    case 'light':
      colorPairs.push(setTextColor(constructColorName(baseName, null, 'color'), 'light'));
      colorPairs.push(setBorderColor(constructColorName(baseName, null, 'border'), 'light'));
      colorPairs.push([constructColorName(baseName, key, 'lighter'), lightenToString(color, 7, -10)]);
      break;

    case 'dark':
      colorPairs.push(setTextColor(constructColorName(baseName, null, 'color'), 'dark'));
      colorPairs.push(setBorderColor(constructColorName(baseName, null, 'border'), 'dark'));
      colorPairs.push([constructColorName(baseName, key, 'lighter'), lightenToString(color, 15, 15)]);
      break;
  }

  return colorPairs;
}

function parseColors([baseName, colors]) {
  const keys = Object.keys(colors);
  const colorPairs = [];

  for (const key of keys) {
    colorPairs.push([constructColorName(baseName, key), colors[key]]);

    if (needsVariant(baseName)) {
      const hslColor = colorToHsla(colors[key]);

      if (typeof hslColor === 'string') {
        return colorPairs;
      }

      const rgbColor = hslToRgb(hslColor);

      if (isLight(rgbColor)) {
        colorPairs.push(...setTheme(hslColor, baseName, key, 'light'));
      } else {
        colorPairs.push(...setTheme(hslColor, baseName, key, 'dark'));
      }
    }
  }

  return colorPairs;
} // eslint-disable-next-line @typescript-eslint/ban-types


function memoize(fnToMemoize) {
  const cache = new Map();
  return function (...args) {
    const key = JSON.stringify([fnToMemoize.name, args]);

    if (cache.get(key) === undefined) {
      cache.set(key, fnToMemoize(...args));
    }

    return cache.get(key);
  };
}

const buildCustomProperties = memoize(buildCustomPropertiesNoMemo);

export { buildCustomProperties, buildCustomPropertiesNoMemo, buildThemeContext, needsVariant, setBorderColor, setTextColor, setTheme, toCssCustomPropertySyntax, toString };
