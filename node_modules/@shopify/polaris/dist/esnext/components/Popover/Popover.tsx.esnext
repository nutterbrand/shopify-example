import React$1, { useState, useRef, useCallback, useEffect, Children } from 'react';
import { useUniqueId } from '../../utilities/unique-id/hooks.ts.esnext';
import { portal } from '../shared.ts.esnext';
import { findFirstFocusableNodeIncludingDisabled, focusNextFocusableNode } from '../../utilities/focus.ts.esnext';
import { Portal as Portal$1 } from '../Portal/Portal.tsx.esnext';
import { Section as Section$1 } from './components/Section/Section.tsx.esnext';
import { Pane as Pane$1 } from './components/Pane/Pane.tsx.esnext';
import { PopoverOverlay as PopoverOverlay$1, PopoverCloseSource } from './components/PopoverOverlay/PopoverOverlay.tsx.esnext';
export { PopoverCloseSource } from './components/PopoverOverlay/PopoverOverlay.tsx.esnext';
import { setActivatorAttributes as setActivatorAttributes$1 } from './set-activator-attributes.ts.esnext';

// TypeScript can't generate types that correctly infer the typing of
// subcomponents so explicitly state the subcomponents in the type definition.
// Letting this be implicit works in this project but fails in projects that use
// generated *.d.ts files.
const Popover = function Popover({
  activatorWrapper = 'div',
  children,
  onClose,
  activator,
  preventFocusOnClose,
  active,
  fixed,
  ariaHaspopup,
  preferInputActivator = true,
  colorScheme,
  ...rest
}) {
  const [activatorNode, setActivatorNode] = useState();
  const activatorContainer = useRef(null);
  const WrapperComponent = activatorWrapper;
  const id = useUniqueId('popover');
  const setAccessibilityAttributes = useCallback(() => {
    if (activatorContainer.current == null) {
      return;
    }

    const firstFocusable = findFirstFocusableNodeIncludingDisabled(activatorContainer.current);
    const focusableActivator = firstFocusable || activatorContainer.current;
    const activatorDisabled = 'disabled' in focusableActivator && Boolean(focusableActivator.disabled);
    setActivatorAttributes$1(focusableActivator, {
      id,
      active,
      ariaHaspopup,
      activatorDisabled
    });
  }, [id, active, ariaHaspopup]);

  const handleClose = source => {
    onClose(source);

    if (activatorContainer.current == null || preventFocusOnClose) {
      return;
    }

    if ((source === PopoverCloseSource.FocusOut || source === PopoverCloseSource.EscapeKeypress) && activatorNode) {
      const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;

      if (!focusNextFocusableNode(focusableActivator, isInPortal)) {
        focusableActivator.focus();
      }
    }
  };

  useEffect(() => {
    if (!activatorNode && activatorContainer.current) {
      setActivatorNode(activatorContainer.current.firstElementChild);
    } else if (activatorNode && activatorContainer.current && !activatorContainer.current.contains(activatorNode)) {
      setActivatorNode(activatorContainer.current.firstElementChild);
    }

    setAccessibilityAttributes();
  }, [activatorNode, setAccessibilityAttributes]);
  useEffect(() => {
    if (activatorNode && activatorContainer.current) {
      setActivatorNode(activatorContainer.current.firstElementChild);
    }

    setAccessibilityAttributes();
  }, [activatorNode, setAccessibilityAttributes]);
  const portal = activatorNode ? /*#__PURE__*/React$1.createElement(Portal$1, {
    idPrefix: "popover"
  }, /*#__PURE__*/React$1.createElement(PopoverOverlay$1, Object.assign({
    id: id,
    activator: activatorNode,
    preferInputActivator: preferInputActivator,
    onClose: handleClose,
    active: active,
    fixed: fixed,
    colorScheme: colorScheme
  }, rest), children)) : null;
  return /*#__PURE__*/React$1.createElement(WrapperComponent, {
    ref: activatorContainer
  }, Children.only(activator), portal);
};

function isInPortal(element) {
  let parentElement = element.parentElement;

  while (parentElement) {
    if (parentElement.matches(portal.selector)) return false;
    parentElement = parentElement.parentElement;
  }

  return true;
}

Popover.Pane = Pane$1;
Popover.Section = Section$1;

export { Popover };
