"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var koa_better_http_proxy_1 = tslib_1.__importDefault(require("koa-better-http-proxy"));
exports.PROXY_BASE_PATH = '/graphql';
exports.GRAPHQL_PATH_PREFIX = '/admin/api';
var ApiVersion;
(function (ApiVersion) {
    ApiVersion["July19"] = "2019-07";
    ApiVersion["October19"] = "2019-10";
    ApiVersion["January20"] = "2020-01";
    ApiVersion["April20"] = "2020-04";
    ApiVersion["July20"] = "2020-07";
    ApiVersion["October20"] = "2020-10";
    ApiVersion["Unstable"] = "unstable";
    ApiVersion["Unversioned"] = "unversioned";
})(ApiVersion = exports.ApiVersion || (exports.ApiVersion = {}));
function shopifyGraphQLProxy(proxyOptions) {
    return function shopifyGraphQLProxyMiddleware(ctx, next) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, session, shop, accessToken, version;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = ctx.session, session = _a === void 0 ? {} : _a;
                        shop = 'shop' in proxyOptions ? proxyOptions.shop : session.shop;
                        accessToken = 'password' in proxyOptions ? proxyOptions.password : session.accessToken;
                        version = proxyOptions.version;
                        if (!(ctx.path !== exports.PROXY_BASE_PATH || ctx.method !== 'POST')) return [3 /*break*/, 2];
                        return [4 /*yield*/, next()];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                    case 2:
                        if (accessToken == null || shop == null) {
                            ctx.throw(403, 'Unauthorized');
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, koa_better_http_proxy_1.default(shop, {
                                https: true,
                                parseReqBody: false,
                                // Setting request header here, not response. That's why we don't use ctx.set()
                                // proxy middleware will grab this request header
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-Shopify-Access-Token': accessToken,
                                },
                                proxyReqOptDecorator: function (proxyReqOpts) {
                                    delete proxyReqOpts.headers.cookie;
                                    delete proxyReqOpts.headers.Cookie;
                                    return proxyReqOpts;
                                },
                                proxyReqPathResolver: function () {
                                    return exports.GRAPHQL_PATH_PREFIX + "/" + version + "/graphql.json";
                                },
                            })(ctx, 
                            /*
                              We want this middleware to terminate, not fall through to the next in the chain,
                              but sadly it doesn't support not passing a `next` function. To get around this we
                              just pass our own dummy `next` that resolves immediately.
                            */
                            noop)];
                    case 3:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
}
exports.default = shopifyGraphQLProxy;
function noop() {
    return tslib_1.__awaiter(this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
        return [2 /*return*/];
    }); });
}
